/**
 * Vulnerability Selector
 * Selects vulnerabilities for game sessions based on difficulty and history
 * Requirements: 8.2, 8.3, 8.4, 8.5, 5.5
 */

import type { VulnerabilityTemplate } from '../types/vulnerability';
import { loadTemplates } from './templateLoader';
import { getTypesToAvoid } from './historyManager';

/**
 * Select vulnerabilities for a game session
 * Requirements: 8.2, 8.3, 8.4, 8.5, 5.5
 */
export function selectVulnerabilities(
  difficulty: 'easy' | 'hard',
  excludeTypes: string[] = []
): VulnerabilityTemplate[] {
  const { templates } = loadTemplates();
  
  // Determine count based on difficulty
  const count = difficulty === 'easy' ? 3 : Math.floor(Math.random() * 2) + 4; // 4 or 5 for hard
  
  // Get types to avoid from history
  const typesToAvoid = getTypesToAvoid();
  const allExcluded = [...excludeTypes, ...typesToAvoid];
  
  // Filter available templates
  let available = templates.filter(t => !allExcluded.includes(t.type));
  
  // If we don't have enough templates, include some from history
  if (available.length < count) {
    available = templates.filter(t => !excludeTypes.includes(t.type));
  }
  
  // Shuffle and select
  const shuffled = shuffleArray([...available]);
  const selected = shuffled.slice(0, count);
  
  // Ensure unique OWASP categories (Requirement 8.5)
  const uniqueCategories = new Set(selected.map(t => t.owaspCategory));
  if (uniqueCategories.size !== selected.length) {
    // If duplicates, try again with different selection
    return selectVulnerabilitiesUnique(templates, count, allExcluded);
  }
  
  return selected;
}

/**
 * Select vulnerabilities ensuring unique OWASP categories
 */
function selectVulnerabilitiesUnique(
  templates: VulnerabilityTemplate[],
  count: number,
  excludeTypes: string[]
): VulnerabilityTemplate[] {
  const available = templates.filter(t => !excludeTypes.includes(t.type));
  const selected: VulnerabilityTemplate[] = [];
  const usedCategories = new Set<string>();
  
  const shuffled = shuffleArray([...available]);
  
  for (const template of shuffled) {
    if (selected.length >= count) break;
    
    if (!usedCategories.has(template.owaspCategory)) {
      selected.push(template);
      usedCategories.add(template.owaspCategory);
    }
  }
  
  // If we still don't have enough, relax the category constraint
  if (selected.length < count) {
    for (const template of shuffled) {
      if (selected.length >= count) break;
      if (!selected.includes(template)) {
        selected.push(template);
      }
    }
  }
  
  return selected;
}

/**
 * Shuffle array using Fisher-Yates algorithm
 */
function shuffleArray<T>(array: T[]): T[] {
  const result = [...array];
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
}

/**
 * Check if two vulnerability sets are identical
 * Requirements: 1.1
 */
export function areSetsIdentical(set1: string[], set2: string[]): boolean {
  if (set1.length !== set2.length) return false;
  
  const sorted1 = [...set1].sort();
  const sorted2 = [...set2].sort();
  
  return sorted1.every((type, index) => type === sorted2[index]);
}
