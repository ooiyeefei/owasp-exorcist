# Design Document: Dynamic Vulnerability Generator

## Overview

The Dynamic Vulnerability Generator (DVG) transforms The Digital Exorcism from a static educational game into an infinite security training simulator. By leveraging the OWASP MCP server and Kiro's AI code generation capabilities, the system dynamically creates unique vulnerable React components for each game session, ensuring players encounter varied security challenges and learn through diverse, realistic examples.

### Key Innovation

Instead of manually crafting 3 fixed vulnerable components, we use Kiro as a "vulnerability injection engine" that:
1. Queries the OWASP MCP for real vulnerability patterns and educational content
2. Generates syntactically valid, realistic React/TypeScript components containing specific vulnerabilities
3. Writes these components to disk and integrates them with the game UI
4. Tracks player history to ensure variety across sessions
5. Adapts complexity based on difficulty mode

This approach makes the game infinitely replayable while teaching real-world security concepts through AI-generated, production-like code examples.

## Architecture

### High-Level Flow

```
Player Starts Game
    ‚Üì
Game Hook Triggers Kiro
    ‚Üì
Kiro Queries OWASP MCP ‚Üê [Vulnerability Database]
    ‚Üì
Kiro Generates Vulnerable Components (3-5)
    ‚Üì
Components Written to Disk
    ‚Üì
Corruption State Updated
    ‚Üì
Dashboard Auto-Refreshes
    ‚Üì
Player Fixes Vulnerabilities
    ‚Üì
Measure Hook Detects Fixes
    ‚Üì
Corruption Drops ‚Üí Victory!
```

### System Components

1. **Game Initialization Hook** (`start-game-dynamic.cjs`)
   - Triggers when player starts a new game
   - Constructs a prompt for Kiro with difficulty settings and history
   - Invokes Kiro's code generation capabilities
   - Waits for generation completion

2. **Vulnerability Template System**
   - JSON-based templates defining vulnerability patterns
   - Each template specifies: OWASP category, code pattern, difficulty range, educational content
   - Templates are used by Kiro as guidance for code generation

3. **Kiro Generation Engine**
   - Receives structured prompts from the game hook
   - Uses OWASP MCP tools to fetch current vulnerability data
   - Generates 3-5 unique React components with embedded vulnerabilities
   - Ensures syntactic validity and realistic code patterns
   - Writes components to `src/components/vulnerable/generated/`

4. **History Tracking System**
   - Stores player's encountered vulnerability types in localStorage
   - Influences future vulnerability selection for variety
   - Provides statistics on learning progress

5. **Dashboard Integration**
   - Dynamically imports generated components
   - Displays vulnerability hints based on difficulty mode
   - Updates in real-time as corruption state changes

## Components and Interfaces

### 1. Vulnerability Template Schema

```typescript
interface VulnerabilityTemplate {
  id: string;                    // Unique identifier (e.g., "hardcoded-secret-v1")
  owaspCategory: string;         // OWASP classification (e.g., "A02:2021")
  type: string;                  // Vulnerability type (e.g., "hardcoded-secret")
  name: string;                  // Display name (e.g., "Hardcoded API Key")
  description: string;           // Educational description
  severity: 'low' | 'medium' | 'high' | 'critical';
  difficultyRange: {
    min: number;                 // 1-10 scale
    max: number;
  };
  codePattern: {
    vulnerablePattern: string;   // Regex or code snippet showing the vulnerability
    fixPattern: string;          // Example of the correct implementation
  };
  hints: {
    easy: string[];              // Obvious hints for Easy mode
    hard: string[];              // Subtle hints for Hard mode
  };
  educationalContent: {
    analogy: string;             // Fun metaphor (e.g., "like leaving keys under doormat")
    realWorldImpact: string;     // Real breach examples
    preventionTip: string;       // How to prevent
    awsServices: Array<{         // AWS services that address this vulnerability
      name: string;              // e.g., "AWS Secrets Manager"
      description: string;       // Brief explanation of how it helps
      useCase: string;           // Specific use case for this vulnerability
      documentationUrl: string;  // Link to AWS docs
    }>;
  };
}
```

### 2. Generation Request Interface

```typescript
interface GenerationRequest {
  sessionId: string;
  difficulty: 'easy' | 'hard';
  count: number;                 // 3-5 vulnerabilities
  excludeTypes: string[];        // Recently used types from history
  owaspPriority: boolean;        // Prioritize OWASP Top 10
}
```

### 3. Generated Component Metadata

```typescript
interface GeneratedComponent {
  filename: string;              // e.g., "VulnerableAuth.tsx"
  componentName: string;         // e.g., "VulnerableAuth"
  vulnerabilityType: string;     // e.g., "hardcoded-secret"
  owaspCategory: string;         // e.g., "A02:2021"
  difficulty: number;            // 1-10
  hints: string[];               // Difficulty-appropriate hints
  generatedAt: string;           // ISO timestamp
  templateId: string;            // Source template
}
```

### 4. Corruption State Extension

```typescript
interface CorruptionState {
  corruptionLevel: number;
  vulnerabilities: Array<{
    type: string;
    file: string;
    pattern: string;
    description: string;
    severity: string;
    count: number;
    // NEW: Dynamic generation metadata
    componentName?: string;
    owaspCategory?: string;
    hints?: string[];
    generatedAt?: string;
  }>;
  // NEW: Session tracking
  sessionId?: string;
  difficulty?: 'easy' | 'hard';
  generatedComponents?: GeneratedComponent[];
  timestamp: number;
  lastScan: string;
  scanDuration: number;
}
```

### 5. Player History Schema

```typescript
interface PlayerHistory {
  sessions: Array<{
    sessionId: string;
    startedAt: string;
    completedAt?: string;
    difficulty: 'easy' | 'hard';
    vulnerabilities: string[];   // Types encountered
    fixedCount: number;
    totalCount: number;
  }>;
  encounteredTypes: {
    [type: string]: number;      // Count of encounters per type
  };
  totalSessions: number;
  totalFixes: number;
}
```

## Data Models

### Vulnerability Template Library

The system ships with 8-10 pre-defined templates covering common OWASP vulnerabilities with AWS security service recommendations:

1. **Hardcoded Secrets** (A02:2021 - Cryptographic Failures)
   - API keys, passwords, tokens in source code
   - Easy: Variable named `API_KEY` with obvious string
   - Hard: Obfuscated in config object or encoded
   - **AWS Services**: 
     - **AWS Secrets Manager**: Securely store and rotate API keys, database credentials, and secrets
     - **AWS Systems Manager Parameter Store**: Store configuration data and secrets with encryption
     - **AWS KMS**: Encrypt secrets at rest and manage encryption keys

2. **XSS via dangerouslySetInnerHTML** (A03:2021 - Injection)
   - Unsafe HTML rendering
   - Easy: Direct `dangerouslySetInnerHTML` with user input
   - Hard: Nested in helper function or component prop
   - **AWS Services**:
     - **AWS WAF**: Filter malicious web requests and block XSS attacks at the edge
     - **Amazon CloudFront**: Use security headers (CSP) to prevent XSS execution
     - **AWS Shield**: Protect against DDoS and application layer attacks

3. **Code Injection via eval()** (A03:2021 - Injection)
   - Arbitrary code execution
   - Easy: Direct `eval(userInput)`
   - Hard: Wrapped in try-catch or utility function
   - **AWS Services**:
     - **AWS Lambda**: Run code in isolated execution environments with limited permissions
     - **AWS IAM**: Enforce least-privilege access to prevent code execution exploits
     - **Amazon Inspector**: Scan for vulnerabilities in application code and dependencies

4. **SQL Injection** (A03:2021 - Injection)
   - String concatenation in queries
   - Easy: Obvious template string with user input
   - Hard: Hidden in query builder function
   - **AWS Services**:
     - **AWS WAF**: Block SQL injection attempts with managed rule sets
     - **Amazon RDS**: Use parameterized queries and IAM database authentication
     - **AWS GuardDuty**: Detect anomalous database access patterns

5. **Insecure Direct Object Reference** (A01:2021 - Broken Access Control)
   - Accessing resources without authorization checks
   - Easy: Direct array access with user-provided index
   - Hard: Nested in data fetching logic
   - **AWS Services**:
     - **AWS IAM**: Enforce fine-grained access control policies
     - **Amazon Cognito**: Implement user authentication and authorization
     - **AWS Lake Formation**: Control access to data lake resources

6. **Missing Input Validation** (A04:2021 - Insecure Design)
   - Accepting untrusted input without validation
   - Easy: No validation on form submission
   - Hard: Partial validation with gaps
   - **AWS Services**:
     - **AWS WAF**: Validate and sanitize input at the application layer
     - **Amazon API Gateway**: Implement request validation and throttling
     - **AWS Lambda Authorizers**: Validate tokens and enforce business logic

7. **Insecure Deserialization** (A08:2021)
   - Unsafe JSON parsing or object reconstruction
   - Easy: Direct `JSON.parse()` without validation
   - Hard: Custom deserializer with vulnerabilities
   - **AWS Services**:
     - **AWS Lambda**: Isolate deserialization in sandboxed environments
     - **Amazon API Gateway**: Validate request schemas before processing
     - **AWS CloudWatch**: Monitor for suspicious deserialization patterns

8. **Insufficient Logging** (A09:2021 - Security Logging Failures)
   - Missing security event logging
   - Easy: No logging in authentication function
   - Hard: Logging present but missing critical events
   - **AWS Services**:
     - **AWS CloudTrail**: Log all API calls and user activity across AWS services
     - **Amazon CloudWatch Logs**: Centralize application and security logs
     - **AWS Security Hub**: Aggregate security findings and compliance checks
     - **Amazon GuardDuty**: Detect threats using machine learning on logs

### File Structure

```
src/
  components/
    vulnerable/
      generated/              # Dynamic components go here
        .gitignore           # Ignore generated files
        README.md            # Explains this directory
      LeakyComponent.tsx     # Original examples (kept for reference)
      InjectionComponent.tsx
      UnsafeComponent.tsx
  
.kiro/
  hooks/
    start-game-dynamic.cjs   # New dynamic game starter
    measure-corruption.cjs   # Updated to handle generated components
  
  templates/
    vulnerabilities/         # Template library
      hardcoded-secret.json
      xss-dangerous-html.json
      code-injection-eval.json
      sql-injection.json
      idor.json
      missing-validation.json
      insecure-deserialization.json
      insufficient-logging.json
```

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system-essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*

### Property 1: Session Uniqueness
*For any* two consecutive game sessions, the generated vulnerability sets should be different (no identical combinations).
**Validates: Requirements 1.1, 1.3, 1.4**

### Property 2: Vulnerability Type Variety
*For any* loaded template library, it should contain at least 5 distinct OWASP vulnerability types.
**Validates: Requirements 1.2**

### Property 3: MCP Integration
*For any* vulnerability generation request, the system should make at least one call to the OWASP MCP server to fetch vulnerability details.
**Validates: Requirements 2.1**

### Property 4: OWASP Metadata Completeness
*For any* generated component, its metadata should include both OWASP classification and description fields.
**Validates: Requirements 2.2**

### Property 5: Educational Content Provision
*For any* vulnerability fix event, the system should provide educational content containing OWASP documentation references.
**Validates: Requirements 2.3**

### Property 6: OWASP Top 10 Prioritization
*For any* generated vulnerability set, the majority (>50%) should be from the current OWASP Top 10 list.
**Validates: Requirements 2.4**

### Property 7: Valid React Component Generation
*For any* generated component file, it should be parseable as valid TypeScript/React code (no syntax errors).
**Validates: Requirements 3.2**

### Property 8: Required Code Elements
*For any* generated component, it should contain at least one import statement, one TypeScript type annotation, and one React hook call.
**Validates: Requirements 3.3**

### Property 9: Dashboard Integration
*For any* generated component, it should export a default function component that can be imported by the Dashboard.
**Validates: Requirements 3.4**

### Property 10: Easy Mode Hint Markers
*For any* component generated in Easy mode, it should contain at least one code comment with hint keywords (e.g., "TODO", "VULNERABILITY", "FIX").
**Validates: Requirements 4.1, 4.3**

### Property 11: Hard Mode Hint Absence
*For any* component generated in Hard mode, it should not contain obvious hint comments or variable names indicating security issues.
**Validates: Requirements 4.2, 4.4**

### Property 12: Session History Recording
*For any* completed game session, the history should contain a record with the correct vulnerability types that were generated.
**Validates: Requirements 5.1**

### Property 13: Fix Event Logging
*For any* vulnerability fix event, a log entry should be created containing the vulnerability type and timestamp.
**Validates: Requirements 5.2**

### Property 14: History Accumulation
*For any* sequence of multiple game sessions, the history should contain records for all sessions (no data loss).
**Validates: Requirements 5.3**

### Property 15: Statistics Accuracy
*For any* player history, the statistics function should return all unique OWASP categories that appear in the session records.
**Validates: Requirements 5.4**

### Property 16: History-Informed Selection
*For any* new session generation, if a vulnerability type appears in recent history, it should be less likely to be selected than types not in history.
**Validates: Requirements 5.5**

### Property 17: Template Validation
*For any* template loaded by the system, it should contain all required fields (id, owaspCategory, type, name, codePattern).
**Validates: Requirements 6.2, 6.3**

### Property 18: Dashboard Auto-Registration
*For any* set of generated components, after generation completes, the Dashboard's component list should include all generated component names.
**Validates: Requirements 7.1, 7.2**

### Property 19: Corruption State Synchronization
*For any* component generation event, the corruption-state.json file should be updated to include metadata for all generated components.
**Validates: Requirements 7.3**

### Property 20: Session Cleanup
*For any* game session end event, all generated component files should be removed from the filesystem and the Dashboard state should be reset.
**Validates: Requirements 7.5**

### Property 21: Component Count Range
*For any* game session, the number of generated vulnerable components should be between 3 and 5 (inclusive).
**Validates: Requirements 8.1**

### Property 22: Difficulty Affects Count
*For any* Easy mode session, exactly 3 components should be generated; for any Hard mode session, 4 or 5 components should be generated.
**Validates: Requirements 8.2, 8.3, 8.4**

### Property 23: Category Uniqueness Within Session
*For any* generated vulnerability set within a single session, no two vulnerabilities should have the same OWASP category.
**Validates: Requirements 8.5**

### Property 24: File Output Location
*For any* generated component, the file should be written to the `src/components/vulnerable/generated/` directory.
**Validates: Requirements 9.3**

### Property 25: Post-Generation State Update
*For any* successful generation, the corruption state should be updated and the corruption level should be set to 100%.
**Validates: Requirements 9.4**

### Property 26: Easy Mode Dashboard Hints
*For any* Easy mode session, the Dashboard should display vulnerability type hints for each generated component.
**Validates: Requirements 10.1**

### Property 27: Help Response Content
*For any* help request about a specific vulnerability, Kiro's response should contain the vulnerability type name and OWASP category.
**Validates: Requirements 10.3**

### Property 28: Easy Mode TODO Comments
*For any* component generated in Easy mode, it should contain at least one TODO comment indicating the vulnerability location.
**Validates: Requirements 10.4**

### Property 29: AWS Service Recommendations
*For any* vulnerability template, it should include at least one AWS security service recommendation with name, description, and use case.
**Validates: Requirements 11.1, 11.2, 11.4**

### Property 30: AWS Service Prioritization
*For any* vulnerability type with multiple applicable AWS services, the primary recommendation should be the most commonly used service for that vulnerability category.
**Validates: Requirements 11.5**

### Property 31: Educational Content Completeness
*For any* vulnerability fix event, the educational content should include both OWASP classification and at least one AWS service recommendation.
**Validates: Requirements 12.2**

### Property 32: Session Summary AWS Services
*For any* completed game session, the summary should list all AWS services that could have prevented the encountered vulnerabilities.
**Validates: Requirements 12.3**

### Property 33: AWS Documentation Links
*For any* AWS service recommendation, it should include a valid documentation URL pointing to AWS official documentation.
**Validates: Requirements 12.5**

## Error Handling

### MCP Server Unavailable
- **Scenario**: OWASP MCP server is offline or unreachable
- **Handling**: 
  - Fall back to cached vulnerability templates stored locally
  - Display toast notification: "Using offline vulnerability database"
  - Log warning for debugging
  - Continue game initialization with cached data

### Code Generation Failure
- **Scenario**: Kiro fails to generate valid component code
- **Handling**:
  - Retry up to 2 times with adjusted parameters
  - If still failing, fall back to pre-built example components
  - Notify player: "Using example vulnerabilities for this session"
  - Log error details for improvement

### Invalid Template
- **Scenario**: Template file is malformed or missing required fields
- **Handling**:
  - Skip the invalid template during loading
  - Log error with template ID and missing fields
  - Continue with remaining valid templates
  - If <5 valid templates remain, show warning to developer

### File System Errors
- **Scenario**: Cannot write generated components to disk
- **Handling**:
  - Check directory permissions
  - Attempt to create directory if missing
  - If still failing, show error modal to player
  - Provide manual fix instructions (check permissions)

### Syntax Errors in Generated Code
- **Scenario**: Generated component has TypeScript/React syntax errors
- **Handling**:
  - Run TypeScript compiler check before finalizing
  - If errors found, regenerate with stricter validation
  - Maximum 3 regeneration attempts
  - Fall back to template-based generation if AI generation fails

### History Corruption
- **Scenario**: Player history data is corrupted or invalid
- **Handling**:
  - Attempt to parse and recover partial data
  - If unrecoverable, reset history with warning
  - Backup corrupted data for debugging
  - Continue with fresh history

## Testing Strategy

### Unit Testing

We'll use **Vitest** (already in the project) for unit tests covering:

1. **Template Validation**
   - Test that template loader correctly validates required fields
   - Test that invalid templates are rejected
   - Test that valid templates are loaded successfully

2. **Component Metadata Extraction**
   - Test parsing of generated component files
   - Test extraction of vulnerability patterns
   - Test OWASP category identification

3. **History Management**
   - Test session recording
   - Test history accumulation across sessions
   - Test statistics calculation

4. **Difficulty Mode Logic**
   - Test that Easy mode generates 3 components
   - Test that Hard mode generates 4-5 components
   - Test hint inclusion/exclusion based on mode

### Property-Based Testing

We'll use **fast-check** (TypeScript property-based testing library) for universal properties:

**Configuration**: Each property test should run a minimum of 100 iterations to ensure thorough coverage.

**Tagging**: Each property-based test must include a comment explicitly referencing the correctness property from this design document using the format: `**Feature: dynamic-vulnerability-generator, Property {number}: {property_text}**`

**Implementation**: Each correctness property must be implemented by a SINGLE property-based test.

1. **Property 1: Session Uniqueness**
   - Generate arbitrary pairs of sessions
   - Verify vulnerability sets are different
   - **Feature: dynamic-vulnerability-generator, Property 1: Session Uniqueness**

2. **Property 7: Valid React Component Generation**
   - Generate arbitrary component code
   - Parse with TypeScript compiler
   - Verify no syntax errors
   - **Feature: dynamic-vulnerability-generator, Property 7: Valid React Component Generation**

3. **Property 8: Required Code Elements**
   - Generate arbitrary components
   - Verify presence of imports, types, hooks
   - **Feature: dynamic-vulnerability-generator, Property 8: Required Code Elements**

4. **Property 21: Component Count Range**
   - Generate arbitrary sessions
   - Verify component count is 3-5
   - **Feature: dynamic-vulnerability-generator, Property 21: Component Count Range**

5. **Property 23: Category Uniqueness Within Session**
   - Generate arbitrary vulnerability sets
   - Verify no duplicate OWASP categories
   - **Feature: dynamic-vulnerability-generator, Property 23: Category Uniqueness Within Session**

### Integration Testing

1. **End-to-End Game Flow**
   - Start game ‚Üí Generate components ‚Üí Fix vulnerabilities ‚Üí Verify corruption drops
   - Test both Easy and Hard modes
   - Verify Dashboard updates correctly

2. **MCP Integration**
   - Test actual calls to OWASP MCP server
   - Verify data retrieval and parsing
   - Test fallback when MCP unavailable

3. **File System Operations**
   - Test component file creation
   - Test cleanup on session end
   - Test handling of existing files

### Manual Testing Checklist

- [ ] Generated components render correctly in browser
- [ ] Vulnerabilities are realistic and educational
- [ ] Hints are appropriate for difficulty level
- [ ] Dashboard displays all generated components
- [ ] Corruption level updates when vulnerabilities are fixed
- [ ] History tracking works across multiple sessions
- [ ] Game is fun and engaging to play

## Implementation Notes

### AWS Security Service Integration

Each vulnerability fix will include educational content about relevant AWS services:

**Example: Hardcoded Secret Fix**
```
üéâ Demon banished! Refresh your browser to see the corruption drop!

üéì Quick Lesson: Hardcoded secrets are like leaving your house key under the doormat - everyone knows to look there!

‚òÅÔ∏è AWS Solution:
‚Ä¢ AWS Secrets Manager: Automatically rotate and manage secrets like API keys and database passwords
‚Ä¢ Use Case: Store your API_KEY in Secrets Manager, retrieve it at runtime using AWS SDK
‚Ä¢ Pro Tip: Secrets Manager integrates with RDS, Redshift, and DocumentDB for automatic rotation

üìö Learn More: https://aws.amazon.com/secrets-manager/

üí° In production, you'd use:
import { SecretsManagerClient, GetSecretValueCommand } from "@aws-sdk/client-secrets-manager";
const secret = await client.send(new GetSecretValueCommand({ SecretId: "my-api-key" }));
```

**Example: XSS Fix**
```
üéâ XSS demon exorcised! The vampire has been uninvited!

üéì Quick Lesson: dangerouslySetInnerHTML is like inviting a vampire into your home - once they're in, chaos ensues!

‚òÅÔ∏è AWS Solution:
‚Ä¢ AWS WAF: Block XSS attacks with managed rule sets before they reach your application
‚Ä¢ Amazon CloudFront: Set Content-Security-Policy headers to prevent script execution
‚Ä¢ Use Case: Deploy WAF rules on your CloudFront distribution to filter malicious payloads

üìö Learn More: https://aws.amazon.com/waf/

üí° In production, you'd configure:
- WAF Rule: AWSManagedRulesKnownBadInputsRuleSet
- CloudFront Header: Content-Security-Policy: default-src 'self'
```

### Kiro Prompt Engineering

The game hook will construct detailed prompts for Kiro that include:

```
You are generating vulnerable React components for The Digital Exorcism security training game.

Session ID: {sessionId}
Difficulty: {difficulty}
Component Count: {count}
Exclude Types: {excludeTypes}

For each component:
1. Query the OWASP MCP for details on vulnerability type: {type}
2. Generate a realistic React functional component with TypeScript
3. Embed the vulnerability naturally within business logic
4. Include appropriate imports, types, and hooks
5. {difficulty === 'easy' ? 'Add TODO comments hinting at the vulnerability' : 'Use realistic variable names without hints'}
6. Export as default

Component requirements:
- Must be valid TypeScript/React code
- Must render a functional UI
- Must integrate with Dashboard without manual wiring
- Must demonstrate the vulnerability clearly
- Must follow project code style

Write each component to: src/components/vulnerable/generated/{ComponentName}.tsx
```

### Dashboard Dynamic Import

The Dashboard will use dynamic imports to load generated components:

```typescript
const [generatedComponents, setGeneratedComponents] = useState<React.ComponentType[]>([]);

useEffect(() => {
  const loadGeneratedComponents = async () => {
    const components = [];
    for (const meta of corruptionState.generatedComponents || []) {
      try {
        const module = await import(`./vulnerable/generated/${meta.filename}`);
        components.push(module.default);
      } catch (error) {
        console.error(`Failed to load ${meta.filename}:`, error);
      }
    }
    setGeneratedComponents(components);
  };
  
  loadGeneratedComponents();
}, [corruptionState]);
```

### Performance Considerations

- **Generation Time**: Kiro may take 10-30 seconds to generate 3-5 components
  - Show loading spinner with progress updates
  - Display "Summoning demons..." flavor text
  
- **File System**: Generated components are temporary
  - Clean up on session end
  - Add to .gitignore to avoid committing

- **MCP Calls**: Batch requests when possible
  - Fetch multiple vulnerability details in one call
  - Cache responses for session duration

### Security Considerations

- **Generated Code Safety**: Even though we're generating vulnerable code intentionally:
  - Isolate generated components in sandboxed directory
  - Never execute generated code server-side
  - Clear warnings in UI that code is intentionally vulnerable
  
- **Player Data**: History tracking should not expose sensitive information
  - Store only vulnerability types and timestamps
  - No personal data or code snippets
  - Use localStorage (client-side only)

## Future Enhancements

1. **Multiplayer Mode**: Compete with friends to fix vulnerabilities fastest
2. **Custom Difficulty Levels**: Beginner, Intermediate, Expert, Nightmare
3. **Vulnerability Chains**: Multi-step exploits requiring multiple fixes
4. **Code Review Mode**: Review AI-generated code for vulnerabilities (no hints)
5. **Leaderboards**: Track fastest fixes and most sessions completed
6. **Achievement System**: Badges for fixing specific vulnerability types
7. **Vulnerability Marketplace**: Community-contributed templates
8. **AI Opponent**: Kiro generates increasingly complex vulnerabilities as you improve

## Conclusion

The Dynamic Vulnerability Generator transforms The Digital Exorcism into a powerful, infinitely replayable security training platform. By leveraging Kiro's AI capabilities and the OWASP MCP, we create a unique learning experience where every game session teaches new security concepts through realistic, production-like code examples. This design ensures scalability, maintainability, and most importantly, an engaging educational experience that makes learning security fun and memorable.
